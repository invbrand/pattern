<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRAND IMAGE PATTERN GENERATOR</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            overscroll-behavior: none;
            background-color: #FFFFFF; 
            color: #000000; 
        }
        
        .custom-slider {
            -webkit-appearance: none; appearance: none; width: 100%; height: 2px; 
            background: #000000; outline: none; margin-top: 6px; 
        }
        .custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 14px; height: 14px; 
            background: #000000; border-radius: 50%; cursor: pointer;
        }
        .custom-slider::-moz-range-thumb {
            width: 14px; height: 14px; background: #000000;
            border-radius: 50%; cursor: pointer; border: none;
        }

        .custom-checkbox {
            appearance: none; -webkit-appearance: none; -moz-appearance: none;
            width: 20px; height: 20px; background-color: white;
            border: 1px solid black; cursor: pointer; position: relative;
            display: inline-block; vertical-align: middle;
        }
        .custom-checkbox:checked::after {
            content: ''; position: absolute; left: 6px; top: 3px;
            width: 5px; height: 10px; border: solid black;
            border-width: 0 2px 2px 0; transform: rotate(45deg);
        }

        .radio-input { opacity: 0; width: 0; height: 0; position: absolute; }

        /* Shape Color Swatches */
        .radio-label.color-swatch-label {
            width: 20px; height: 20px; border: 1px solid #CCCCCC; /* Default light gray border */
            cursor: pointer; display: block; box-sizing: border-box;
        }
        .radio-input:checked + .radio-label.color-swatch-label {
            outline: 2px solid #000000; /* Black outline for selected */
            outline-offset: 1px; 
        }

        /* Text-based Buttons (Resolution and Background Color) */
        .radio-label.text-button-label {
            padding: 4px 10px; border: 1px solid black;
            background-color: white; color: black; text-transform: uppercase;
            font-size: 0.75rem; 
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            cursor: pointer; white-space: nowrap; text-align: center;
        }
        .radio-input:checked + .radio-label.text-button-label {
            background-color: black; color: white;
        }
        
        .preview-box {
            background-color: #F3F4F6; border: 1px solid black;
            display: flex; align-items: center; justify-content: center;
            position: relative; overflow: hidden; 
        }
        #outputCanvas { display: block; max-width: 100%; max-height: 100%; }

        .control-label {
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            font-size: 0.75rem; text-transform: uppercase; color: black;
            display: block; margin-bottom: 0.125rem; 
        }
        .page-container { max-width: 1600px; margin-left: auto; margin-right: auto; }
    </style>
</head>
<body class="p-4 sm:p-6 md:p-10">
    <div id="pageLoader" class="fixed top-0 left-0 w-full h-full bg-white bg-opacity-90 flex items-center justify-center z-50">
        <div class="w-16 h-16 border-4 border-t-4 border-t-black border-gray-200 rounded-full animate-spin"></div>
    </div>

    <div class="page-container">
        <div class="flex justify-between items-start mb-6 md:mb-10">
            <div>
                <h1 class="text-sm sm:text-base font-bold tracking-wider">BRAND IMAGE PATTERN GENERATOR</h1>
                <p class="text-xs text-gray-500 mt-1">Upload an image and customize it to create a pattern.</p>
            </div>
            <button id="uploadTriggerButton" class="bg-black text-white px-6 py-2 sm:px-8 text-xs hover:bg-gray-800 transition-colors">UPLOAD</button>
            <input type="file" id="imageUploadInput" class="hidden" accept="image/*">
        </div>

        <div class="flex flex-col lg:flex-row gap-6 md:gap-10">
            <div class="lg:w-[280px] lg:flex-none space-y-5">
                <div class="space-y-3">
                    <div>
                        <label for="patternDensitySlider" class="control-label">DENSITY (<span id="patternDensityValue">130</span>)</label>
                        <input type="range" id="patternDensitySlider" min="1" max="200" value="130" class="custom-slider">
                    </div>
                    <div>
                        <label for="randomnessSlider" class="control-label">SHAPE MIX (<span id="randomnessValue">0.50</span>)</label>
                        <input type="range" id="randomnessSlider" min="0" max="1" value="0.50" step="0.01" class="custom-slider">
                    </div>
                    <div>
                        <label for="brightnessThresholdSlider" class="control-label">SENSITIVITY (<span id="brightnessThresholdValue">90</span>)</label>
                        <input type="range" id="brightnessThresholdSlider" min="0" max="255" value="90" class="custom-slider">
                    </div>
                    <div>
                        <label for="minShapeScaleSlider" class="control-label">MIN SCALE (<span id="minShapeScaleValue">0.10</span>)</label>
                        <input type="range" id="minShapeScaleSlider" min="0.01" max="1.0" value="0.10" step="0.01" class="custom-slider">
                    </div>
                    <div>
                        <label for="maxShapeScaleSlider" class="control-label">MAX SCALE (<span id="maxShapeScaleValue">0.70</span>)</label>
                        <input type="range" id="maxShapeScaleSlider" min="0.01" max="1.0" value="0.70" step="0.01" class="custom-slider">
                    </div>
                </div>

                <div class="space-y-3 pt-2">
                    <label class="control-label">COLORS</label>
                    <div class="flex items-center space-x-2">
                        <span class="control-label w-24 flex-none">SHAPE</span>
                        <div id="shapeColorPickerContainer" class="flex space-x-1"></div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span class="control-label w-24 flex-none">BACKGROUND</span>
                        <div id="bgColorPickerContainer" class="flex flex-wrap gap-1"></div>
                    </div>
                    <div class="flex items-center space-x-2 mt-1">
                         <label for="invertImageToggle" class="control-label w-24 flex-none">INVERT</label>
                         <input type="checkbox" id="invertImageToggle" class="custom-checkbox">
                    </div>
                </div>
            </div>

            <div class="flex-1">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 h-[280px] sm:h-[320px] md:h-[380px] lg:h-[420px]"> 
                    <div id="dropZone" class="preview-box cursor-pointer">
                        <img id="imagePreview" src="#" alt="Upload area" class="hidden max-h-full max-w-full object-contain"/>
                        <div id="dropZoneContent" class="text-center text-gray-400 text-xs sm:text-sm p-2">
                            Click or drag image here
                        </div>
                    </div>
                    <div id="outputCanvasContainer" class="preview-box">
                        <canvas id="outputCanvas"></canvas>
                    </div>
                </div>
                <div class="flex justify-between mt-1 px-1">
                    <span class="text-xs uppercase control-label">START</span>
                    <span class="text-xs uppercase control-label">END</span>
                </div>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-between items-center mt-6 md:mt-10 gap-4">
            <div id="downloadResolutionPickerContainer" class="flex flex-wrap justify-center sm:justify-start gap-1"></div>
            <button id="generateButton" class="bg-black text-white px-10 py-3 sm:px-12 text-xs hover:bg-gray-800 transition-colors w-full sm:w-auto">GENERATE</button>
        </div>
        
        <div id="errorNotification" class="hidden fixed bottom-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg shadow-md z-50" role="alert">
            <strong class="font-bold">Oops!</strong>
            <span class="block sm:inline" id="errorMessageText">Something went wrong.</span>
            <span class="absolute top-0 bottom-0 right-0 px-4 py-3" onclick="document.getElementById('errorNotification').classList.add('hidden')">
                <svg class="fill-current h-6 w-6 text-red-500" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>Close</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1 1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0 1.698z"/></svg>
            </span>
        </div>
    </div>

    <script>
        const BRAND_COLORS_CONFIG = [ 
            { name: "White", hex: "#FFFFFF" }, { name: "Black", hex: "#0F0F0F" },
            { name: "Dark Gray", hex: "#555555" }, { name: "Optimist Blue", hex: "#0C76FE" },
            { name: "Tech Yellow", hex: "#DCF56B" }, { name: "Light Gray", hex: "#CCCCCC" },
            { name: "Sky Blue", hex: "#BEDAE2" }, { name: "Orchid", hex: "#E57DE1" }
        ];
        const DOWNLOAD_RESOLUTIONS_CONFIG = [ 
            { name: "HD", value: 1080 }, { name: "2K", value: 1440 }, 
            { name: "4K", value: 2160 }, { name: "8K", value: 4320 }
        ];

        // Updated Default Selections (user request + input_file_0.png for colors/res)
        const DEFAULT_SHAPE_COLOR_INDEX = 1; // 2nd swatch (Black) from input_file_0.png
        const DEFAULT_BG_COLOR_NAME = "White"; // "WHITE" from input_file_0.png
        const DEFAULT_RESOLUTION_INDEX = 3; // 8K (4th item) from input_file_0.png

        const patternDensitySlider = document.getElementById('patternDensitySlider');
        const patternDensityValueDisplay = document.getElementById('patternDensityValue');
        const randomnessSlider = document.getElementById('randomnessSlider');
        const randomnessValueDisplay = document.getElementById('randomnessValue');
        const brightnessThresholdSlider = document.getElementById('brightnessThresholdSlider');
        const brightnessThresholdValueDisplay = document.getElementById('brightnessThresholdValue');
        const minShapeScaleSlider = document.getElementById('minShapeScaleSlider');
        const minShapeScaleValueDisplay = document.getElementById('minShapeScaleValue');
        const maxShapeScaleSlider = document.getElementById('maxShapeScaleSlider');
        const maxShapeScaleValueDisplay = document.getElementById('maxShapeScaleValue');
        const invertImageToggle = document.getElementById('invertImageToggle');
        
        const bgColorPickerContainer = document.getElementById('bgColorPickerContainer');
        const shapeColorPickerContainer = document.getElementById('shapeColorPickerContainer');
        const downloadResolutionPickerContainer = document.getElementById('downloadResolutionPickerContainer');
        
        const imageUploadInput = document.getElementById('imageUploadInput');
        const uploadTriggerButton = document.getElementById('uploadTriggerButton');
        const dropZone = document.getElementById('dropZone');
        const dropZoneContent = document.getElementById('dropZoneContent');
        const imagePreview = document.getElementById('imagePreview');
        const outputCanvasContainer = document.getElementById('outputCanvasContainer');
        const outputCanvas = document.getElementById('outputCanvas');
        const outputCtx = outputCanvas.getContext('2d');
        const generateButton = document.getElementById('generateButton');
        const errorNotification = document.getElementById('errorNotification');
        const errorMessageText = document.getElementById('errorMessageText');

        let originalImage = null;
        let originalImageAspectRatio = 1;
        let offscreenImageCanvas = document.createElement('canvas');
        let offscreenImageCtx = offscreenImageCanvas.getContext('2d');

        function initialize() {
            // Set initial slider values from user defaults
            patternDensitySlider.value = 130;
            randomnessSlider.value = 0.50;
            brightnessThresholdSlider.value = 90;
            minShapeScaleSlider.value = 0.10;
            maxShapeScaleSlider.value = 0.70;
            invertImageToggle.checked = false; // User default

            const defaultBgColorObj = BRAND_COLORS_CONFIG.find(c => c.name === DEFAULT_BG_COLOR_NAME);
            const defaultBgColorIndex = defaultBgColorObj ? BRAND_COLORS_CONFIG.indexOf(defaultBgColorObj) : 0;

            BRAND_COLORS_CONFIG.forEach((color, index) => {
                createRadioOption(shapeColorPickerContainer, 'shapeColor', color, index === DEFAULT_SHAPE_COLOR_INDEX, 'visualSwatch');
            });
            BRAND_COLORS_CONFIG.forEach((color, index) => {
                createRadioOption(bgColorPickerContainer, 'backgroundColor', color, index === defaultBgColorIndex, 'textButton');
            });
            DOWNLOAD_RESOLUTIONS_CONFIG.forEach((res, index) => {
                createRadioOption(downloadResolutionPickerContainer, 'downloadMaxDimension', res, index === DEFAULT_RESOLUTION_INDEX, 'textButton');
            });
            
            addEventListeners();
            updateSliderValueDisplays(); 
            generatePatternForDisplay(); 
            document.getElementById('pageLoader').style.display = 'none';
        }
        
        function createRadioOption(container, name, optionData, isChecked, type) {
            const uniqueIdPart = type === 'visualSwatch' ? optionData.hex.replace('#', '') : (optionData.value || optionData.name.replace(/\s+/g, ''));
            const radioId = `${name}_${uniqueIdPart}`;
            
            const radioInput = document.createElement('input');
            radioInput.type = 'radio'; radioInput.id = radioId; radioInput.name = name;
            radioInput.value = (type === 'visualSwatch' || name === 'backgroundColor') ? optionData.hex : optionData.value;
            radioInput.className = 'radio-input';
            if (isChecked) radioInput.checked = true;

            const radioLabel = document.createElement('label');
            radioLabel.htmlFor = radioId;
            
            if (type === 'visualSwatch') {
                radioLabel.className = 'radio-label color-swatch-label';
                radioLabel.style.backgroundColor = optionData.hex;
                radioLabel.title = optionData.name;
                radioInput.addEventListener('change', generatePatternForDisplay);
            } else if (type === 'textButton') {
                radioLabel.className = 'radio-label text-button-label';
                radioLabel.innerHTML = `<span>${optionData.name.toUpperCase()}</span>`;
                 if (name === 'backgroundColor') {
                    radioInput.addEventListener('change', generatePatternForDisplay);
                }
            }
            container.appendChild(radioInput); container.appendChild(radioLabel);
        }
        
        function enforceMinMaxScaleLogic() {
            let minVal = parseFloat(minShapeScaleSlider.value);
            let maxVal = parseFloat(maxShapeScaleSlider.value);
            if (minVal > maxVal) {
                if (this === minShapeScaleSlider) maxShapeScaleSlider.value = minVal;
                else minShapeScaleSlider.value = maxVal;
            }
            updateSliderValueDisplays(); 
        }

        function addEventListeners() {
            [patternDensitySlider, randomnessSlider, brightnessThresholdSlider, minShapeScaleSlider, maxShapeScaleSlider].forEach(slider => {
                slider.addEventListener('input', () => {
                    if (slider === minShapeScaleSlider || slider === maxShapeScaleSlider) {
                        enforceMinMaxScaleLogic.call(slider);
                    } else {
                        updateSliderValueDisplays();
                    }
                    generatePatternForDisplay();
                });
            });
            invertImageToggle.addEventListener('change', generatePatternForDisplay);

            uploadTriggerButton.addEventListener('click', () => imageUploadInput.click());
            dropZone.addEventListener('click', () => { if(!originalImage) imageUploadInput.click() });
            imageUploadInput.addEventListener('change', handleImageUploadEvent);
            dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-blue-500', 'border-2'); });
            dropZone.addEventListener('dragleave', () => dropZone.classList.remove('border-blue-500', 'border-2'));
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault(); dropZone.classList.remove('border-blue-500', 'border-2');
                if (e.dataTransfer.files && e.dataTransfer.files[0]) loadImageFromFile(e.dataTransfer.files[0]);
            });
            generateButton.addEventListener('click', handleDownload);
        }
        
        function updateSliderValueDisplays() {
            patternDensityValueDisplay.textContent = patternDensitySlider.value;
            randomnessValueDisplay.textContent = parseFloat(randomnessSlider.value).toFixed(2);
            brightnessThresholdValueDisplay.textContent = brightnessThresholdSlider.value;
            minShapeScaleValueDisplay.textContent = parseFloat(minShapeScaleSlider.value).toFixed(2);
            maxShapeScaleValueDisplay.textContent = parseFloat(maxShapeScaleSlider.value).toFixed(2);
        }

        function handleImageUploadEvent(event) {
            if (event.target.files && event.target.files[0]) loadImageFromFile(event.target.files[0]);
        }

        function showErrorNotification(message) {
            errorMessageText.textContent = message; errorNotification.classList.remove('hidden');
        }
        function clearErrorNotification() { errorNotification.classList.add('hidden'); }

        function loadImageFromFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                originalImage = new Image();
                originalImage.onload = () => {
                    clearErrorNotification();
                    originalImageAspectRatio = originalImage.width / originalImage.height;
                    offscreenImageCanvas.width = originalImage.width;
                    offscreenImageCanvas.height = originalImage.height;
                    offscreenImageCtx.drawImage(originalImage, 0, 0);
                    
                    imagePreview.src = e.target.result;
                    imagePreview.classList.remove('hidden');
                    dropZoneContent.classList.add('hidden');
                    generateButton.disabled = false;
                    generatePatternForDisplay();
                };
                originalImage.onerror = () => { showErrorNotification("Error processing image. Unsupported format or corrupted."); resetImageState(); };
                originalImage.src = e.target.result;
            };
            reader.onerror = () => { showErrorNotification("Could not read the file."); resetImageState(); };
            reader.readAsDataURL(file);
        }
        
        function resetImageState() {
            originalImage = null; originalImageAspectRatio = 1;
            imagePreview.src = "#"; imagePreview.classList.add('hidden');
            dropZoneContent.classList.remove('hidden');
            dropZoneContent.textContent = "Click or drag image here";
            generateButton.disabled = true; generatePatternForDisplay();
        }
        
        function getSelectedRadioValue(radioGroupName) {
            const selectedRadio = document.querySelector(`input[name="${radioGroupName}"]:checked`);
            return selectedRadio ? selectedRadio.value : null;
        }

        function calculateDisplayCanvasDimensions(container, aspectRatio) {
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width - 2; 
            const containerHeight = containerRect.height - 2;
            let canvasWidth, canvasHeight;
            if (containerWidth / containerHeight > aspectRatio) {
                canvasHeight = containerHeight; canvasWidth = containerHeight * aspectRatio;
            } else {
                canvasWidth = containerWidth; canvasHeight = containerWidth / aspectRatio;
            }
            return { width: Math.max(1, Math.round(canvasWidth)), height: Math.max(1, Math.round(canvasHeight)) };
        }
        
        function generatePatternOnCanvas(targetCanvas, targetCtx, isForDownload = false, downloadMaxDim = 0) {
            const density = parseInt(patternDensitySlider.value);
            const randomness = parseFloat(randomnessSlider.value);
            const brightnessThreshold = parseInt(brightnessThresholdSlider.value);
            const minScale = parseFloat(minShapeScaleSlider.value);
            const maxScale = parseFloat(maxShapeScaleSlider.value);
            
            const bgColor = getSelectedRadioValue('backgroundColor') || BRAND_COLORS_CONFIG[0].hex;
            const shapeColor = getSelectedRadioValue('shapeColor') || BRAND_COLORS_CONFIG[1].hex;

            let canvasWidth, canvasHeight;
            if (isForDownload) {
                const ar = originalImage ? originalImageAspectRatio : 1;
                if (ar >= 1) { canvasWidth = downloadMaxDim; canvasHeight = downloadMaxDim / ar; } 
                else { canvasHeight = downloadMaxDim; canvasWidth = downloadMaxDim * ar; }
                canvasWidth = Math.round(canvasWidth); canvasHeight = Math.round(canvasHeight);
            } else {
                const ar = originalImage ? originalImageAspectRatio : (16/9);
                const dims = calculateDisplayCanvasDimensions(targetCanvas.parentElement, ar);
                canvasWidth = dims.width; canvasHeight = dims.height;
            }
            
            targetCanvas.width = canvasWidth; targetCanvas.height = canvasHeight;
            if (!isForDownload) {
                targetCanvas.style.width = `${canvasWidth}px`; targetCanvas.style.height = `${canvasHeight}px`;
            }

            targetCtx.fillStyle = bgColor;
            targetCtx.fillRect(0, 0, canvasWidth, canvasHeight);

            if (!originalImage) {
                if (!isForDownload) {
                    dropZoneContent.textContent = "Click or drag image here"; 
                    dropZoneContent.classList.remove('hidden'); imagePreview.classList.add('hidden');
                    targetCtx.fillStyle = "#6B7280"; 
                    const fontSize = Math.min(16, Math.max(10, canvasWidth / 28));
                    targetCtx.font = `${fontSize}px ui-sans-serif, system-ui`;
                    targetCtx.textAlign = "center";
                    targetCtx.fillText("Pattern preview will appear here", canvasWidth / 2, canvasHeight / 2);
                }
                return;
            }
            
            const numCellsX = density;
            const cellSize = canvasWidth / numCellsX;
            const numCellsY = Math.round(canvasHeight / cellSize);

            for (let yCell = 0; yCell < numCellsY; yCell++) {
                for (let xCell = 0; xCell < numCellsX; xCell++) {
                    const sourceNormX = (xCell + 0.5) / numCellsX;
                    const sourceNormY = (yCell + 0.5) / numCellsY;
                    const sourceX = Math.floor(sourceNormX * originalImage.width);
                    const sourceY = Math.floor(sourceNormY * originalImage.height);
                    const clampedSourceX = Math.min(Math.max(0, sourceX), originalImage.width - 1);
                    const clampedSourceY = Math.min(Math.max(0, sourceY), originalImage.height - 1);
                    
                    const pixelData = offscreenImageCtx.getImageData(clampedSourceX, clampedSourceY, 1, 1).data;
                    let r = pixelData[0], g = pixelData[1], b = pixelData[2];
                    
                    if (invertImageToggle.checked) { r = 255 - r; g = 255 - g; b = 255 - b; }
                    const brightness = 0.2126 * r + 0.7152 * g + 0.0722 * b; 

                    if (brightness < brightnessThreshold) {
                        targetCtx.fillStyle = shapeColor;
                        let drawCircle = Math.random() < randomness;
                        if (randomness <= 0.01) drawCircle = false; else if (randomness >= 0.99) drawCircle = true;

                        const brightnessFactor = Math.max(0, (brightnessThreshold - brightness)) / brightnessThreshold;
                        const actualMinScale = Math.min(minScale, maxScale);
                        const actualMaxScale = Math.max(minScale, maxScale);
                        const currentShapeScaleRatio = actualMinScale + brightnessFactor * (actualMaxScale - actualMinScale);
                        
                        const actualShapeSize = cellSize * currentShapeScaleRatio;
                        const drawX = xCell * cellSize + (cellSize - actualShapeSize) / 2;
                        const drawY = yCell * cellSize + (cellSize - actualShapeSize) / 2;

                        if (drawCircle) {
                            targetCtx.beginPath();
                            targetCtx.arc(drawX + actualShapeSize / 2, drawY + actualShapeSize / 2, actualShapeSize / 2, 0, 2 * Math.PI);
                            targetCtx.fill();
                        } else {
                            targetCtx.fillRect(drawX, drawY, actualShapeSize, actualShapeSize);
                        }
                    }
                }
            }
        }
        
        function generatePatternForDisplay() { generatePatternOnCanvas(outputCanvas, outputCtx, false); }

        function handleDownload() {
            if (!originalImage) { showErrorNotification("Please upload an image first."); return; }

            generateButton.disabled = true;
            const originalButtonText = generateButton.textContent;
            generateButton.innerHTML = `<svg class="animate-spin inline h-4 w-4 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>GENERATING...`;

            setTimeout(() => { 
                const selectedMaxDim = parseInt(getSelectedRadioValue('downloadMaxDimension')) || DOWNLOAD_RESOLUTIONS_CONFIG[0].value;
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                generatePatternOnCanvas(tempCanvas, tempCtx, true, selectedMaxDim);
                
                const dataURL = tempCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                let dlWidth, dlHeight;
                 if (originalImageAspectRatio >= 1) { 
                    dlWidth = selectedMaxDim; dlHeight = Math.round(selectedMaxDim / originalImageAspectRatio);
                } else {
                    dlHeight = selectedMaxDim; dlWidth = Math.round(selectedMaxDim * originalImageAspectRatio);
                }
                link.download = `brand-pattern-${dlWidth}x${dlHeight}.png`;
                link.href = dataURL; document.body.appendChild(link); link.click(); document.body.removeChild(link);
                generateButton.textContent = "GENERATED!";
                setTimeout(() => {
                    generateButton.textContent = originalButtonText; generateButton.disabled = false;
                }, 2000);
            }, 50);
        }
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (outputCanvasContainer.offsetParent !== null) { generatePatternForDisplay(); }
            }, 250);
        });

        initialize();
    </script>
</body>
</html>
