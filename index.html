<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRAND IMAGE PATTERN GENERATOR - V3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            overscroll-behavior: none;
            background-color: #f0f2f5;
        }
        .main-container {
            background-color: #ffffff;
            border-radius: 0.5rem;
            padding: 2rem;
            margin: 1rem auto;
            max-width: 1200px;
        }
        .header-title { color: #000000; font-weight: 600; }
        .header-subtitle { color: #6b7280; font-size: 0.875rem; }
        .action-button {
            background-color: #1f2937;
            color: white;
            padding: 0.5rem 1.5rem;
            border-radius: 0.25rem;
            font-weight: 500;
            font-size: 0.875rem;
            letter-spacing: 0.05em;
            transition: background-color 0.2s;
            text-transform: uppercase;
        }
        .action-button:hover { background-color: #374151; }
        .action-button:disabled { background-color: #9ca3af; cursor: not-allowed; }

        .control-group label.control-label {
            font-weight: 500;
            margin-bottom: 0.75rem;
            display: block;
            font-size: 0.75rem;
            color: #000000;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .control-group .slider-value-label {
            font-size: 0.75rem; color: #4b5563;
        }
        .slider {
            -webkit-appearance: none; width: 100%; height: 4px;
            border-radius: 2px; background: #d1d5db;
            outline: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 14px; height: 14px; border-radius: 50%;
            background: #000000;
            cursor: pointer; border: none;
        }
        .slider::-moz-range-thumb {
            width: 14px; height: 14px; border-radius: 50%;
            background: #000000; cursor: pointer; border: none;
        }

        .colors-section { margin-top: 1.5rem; }
        .color-picker-label {
            font-weight: 500; font-size: 0.75rem; color: #000000;
            text-transform: uppercase; letter-spacing: 0.05em;
            margin-right: 0.75rem;
        }
        .picker-group {
            display: flex; flex-wrap: wrap; gap: 0.25rem;
            align-items: center;
        }
        .picker-group input[type="radio"] {
            opacity: 0; position: absolute; width: 0; height: 0;
        }
        .radio-label.color-radio {
            display: flex; align-items: center; justify-content: center;
            width: 24px; height: 24px;
            border: 1px solid transparent;
            border-radius: 0.125rem;
            cursor: pointer; transition: all 0.2s;
            padding: 0;
        }
        .radio-input:checked + .radio-label.color-radio {
            box-shadow: 0 0 0 2px #000000;
        }
        .color-swatch {
            width: 100%; height: 100%; border-radius: 0.125rem;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .preview-container {
            border: 1px solid #e5e7eb;
            background-color: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            aspect-ratio: var(--image-aspect-ratio, 1/1);
            width: 100%;
            min-height: 300px; /* Ensure a minimum height */
        }
        
        #imagePreview, #patternPreviewCanvas {
            position: absolute;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .select-input {
            width: 100%; padding: 0.3rem 0.5rem; border: 1px solid #d1d5db;
            border-radius: 0.25rem; font-size: 0.8rem; background-color: #fff;
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat; background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        .color-match-picker {
            width: 36px; height: 36px; padding: 2px; border: 1px solid #d1d5db;
            border-radius: 0.25rem; cursor: pointer;
        }
         .radio-label.text-button-label {
            padding: 4px 10px; border: 1px solid black;
            background-color: white; color: black; text-transform: uppercase;
            font-size: 0.75rem;
            cursor: pointer; white-space: nowrap; text-align: center;
        }
        .radio-input:checked + .radio-label.text-button-label {
            background-color: black; color: white;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="p-4 sm:p-6 md:p-10">
    <div class="main-container">
        <header class="flex justify-between items-center mb-8">
            <div>
                <h1 class="text-xl md:text-2xl font-semibold header-title">BRAND IMAGE PATTERN GENERATOR</h1>
                <p class="text-xs header-subtitle">UPLOAD AN IMAGE AND CUSTOMIZE THE PATTERN.</p>
            </div>
            <button id="uploadTriggerButton" class="action-button">UPLOAD</button>
            <input type="file" id="imageUploadInput" class="hidden" accept="image/*">
        </header>

        <div class="flex flex-col lg:flex-row gap-8">
            <!-- Controls Column -->
            <div class="lg:w-[320px] lg:flex-none space-y-6">
                <div class="grid grid-cols-1 gap-y-5">
                     <div class="control-group">
                        <label for="patternDensitySlider" class="control-label">SHAPE DENSITY <span id="patternDensityValue" class="slider-value-label">(170)</span></label>
                        <input type="range" id="patternDensitySlider" min="10" max="200" value="170" class="slider w-full">
                    </div>
                    <div class="control-group">
                        <label for="randomnessSlider" class="control-label">SHAPE MIX <span id="randomnessValue" class="slider-value-label">(0.50)</span></label>
                        <input type="range" id="randomnessSlider" min="0" max="1" value="0.5" step="0.01" class="slider w-full">
                    </div>
                     <div class="control-group">
                        <label for="analysisModeSelect" class="control-label">Analysis Mode</label>
                        <select id="analysisModeSelect" class="select-input">
                            <option value="luminance" selected>Luma Sensitivity</option>
                            <option value="hslAnalysis">HSL (Lightness)</option>
                            <option value="colorDissimilarity">Texture (Color Variation)</option>
                            <option value="colorMatch">Color Match</option>
                            <option value="edgeDetection">Edge Detection</option>
                        </select>
                    </div>
                     <div class="control-group flex items-center justify-between">
                        <label for="invertToggle" class="control-label !mb-0">INVERT ANALYSIS</label>
                        <input type="checkbox" id="invertToggle" class="h-4 w-4 text-black border-gray-400 rounded focus:ring-black" style="accent-color: #000000;" />
                    </div>

                    <div id="luminanceControl" class="control-group">
                        <label for="brightnessThresholdSlider" class="control-label">RELATIVE SENSITIVITY <span id="brightnessThresholdValue" class="slider-value-label">(80%)</span></label>
                        <input type="range" id="brightnessThresholdSlider" min="-100" max="200" value="80" step="1" class="slider w-full">
                    </div>

                    <!-- NEW: Contrast slider, specifically for HSL -->
                    <div id="hslContrastControl" class="control-group hidden">
                        <label for="hslContrastSlider" class="control-label">CONTRAST <span id="hslContrastValue" class="slider-value-label">(x1.0)</span></label>
                        <input type="range" id="hslContrastSlider" min="0.1" max="5.0" value="1.0" step="0.1" class="slider w-full">
                    </div>
                    
                    <div id="colorMatchControl" class="control-group hidden">
                        <label for="colorMatchThresholdSlider" class="control-label">COLOR THRESHOLD <span id="colorMatchThresholdValue" class="slider-value-label">(50)</span></label>
                        <div class="flex items-center gap-4">
                            <input type="range" id="colorMatchThresholdSlider" min="1" max="150" value="50" class="slider w-full">
                            <input type="color" id="colorMatchColorPicker" value="#DCF56B" class="color-match-picker">
                        </div>
                    </div>
                    <hr/>
                     <div class="control-group">
                        <label for="minShapeScaleSlider" class="control-label">MIN SHAPE SIZE <span id="minShapeScaleValue" class="slider-value-label">(0.01)</span></label>
                        <input type="range" id="minShapeScaleSlider" min="0.01" max="1.0" value="0.01" step="0.01" class="slider w-full">
                    </div>
                    <div class="control-group">
                        <label for="maxShapeScaleSlider" class="control-label">MAX SHAPE SIZE <span id="maxShapeScaleValue" class="slider-value-label">(0.90)</span></label>
                        <input type="range" id="maxShapeScaleSlider" min="0.01" max="1.0" value="0.90" step="0.01" class="slider w-full">
                    </div>
                </div>

                <div class="colors-section pt-2">
                    <span class="group-label font-bold text-xs uppercase">COLORS</span>
                     <div class="flex flex-col space-y-3 mt-2">
                        <div class="flex items-center">
                            <span class="color-picker-label w-28 flex-shrink-0">SHAPE</span>
                            <div id="shapeColorPickerContainer" class="picker-group"></div>
                        </div>
                        <div class="flex items-center">
                            <span class="color-picker-label w-28 flex-shrink-0">BACKGROUND</span>
                            <div id="bgColorPickerContainer" class="picker-group"></div>
                        </div>
                    </div>
                </div>

                <div class="control-group pt-4">
                     <label class="control-label">DOWNLOAD RESOLUTION</label>
                     <div id="downloadResolutionPickerContainer" class="flex flex-wrap gap-2"></div>
                </div>

                <button id="generateButton" class="action-button w-full !mt-8 !py-3">GENERATE & DOWNLOAD</button>
            </div>

            <!-- Previews Column -->
            <div class="flex-1 flex flex-col gap-4">
                 <div class="flex flex-col items-center">
                    <p class="text-xs text-gray-500 uppercase mb-2">Original Image</p>
                    <div id="dropZone" class="preview-container cursor-pointer">
                        <img id="imagePreview" src="#" alt="Upload area" class="hidden"/>
                        <div id="dropZoneContent" class="text-center text-gray-400 text-sm p-4">
                             <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true"><path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>
                             <p class="mt-2 font-semibold">CLICK OR DRAG IMAGE HERE</p>
                        </div>
                    </div>
                 </div>
                 <div class="flex flex-col items-center">
                     <p class="text-xs text-gray-500 uppercase mb-2">Pattern Preview</p>
                     <div id="patternPreviewContainer" class="preview-container">
                        <canvas id="patternPreviewCanvas"></canvas>
                     </div>
                 </div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const BRAND_COLORS_CONFIG = [
            { name: "White", hex: "#FFFFFF" }, { name: "Black", hex: "#0F0F0F" },
            { name: "Midnight Blue", hex: "#24248E" }, { name: "Optimist Blue", hex: "#0C76FE" },
            { name: "Tech Yellow", hex: "#DCF56B" }, { name: "Wheat", hex: "#E3CFA8" },
            { name: "Sky Blue", hex: "#BEDAE2" }, { name: "Orchid", hex: "#E57DE1" },
            { name: "Maroon", hex: "#65211A" }
        ];
        const GRAYSCALE_COLORS_CONFIG = Array.from({ length: 11 }, (_, i) => {
            const percentage = i * 10;
            const hexValue = Math.round(255 - (percentage / 100) * 255).toString(16).padStart(2, '0');
            const hex = `#${hexValue}${hexValue}${hexValue}`;
            return { name: `Gray ${100 - percentage}%`, hex: hex };
        });
        const DOWNLOAD_RESOLUTIONS_CONFIG = [
            { name: "HD", value: 1920 }, { name: "2K", value: 2560 },
            { name: "4K", value: 3840 }, { name: "8K", value: 7680 }
        ];

        // --- DOM Elements ---
        const patternDensitySlider = document.getElementById('patternDensitySlider');
        const patternDensityValueDisplay = document.getElementById('patternDensityValue');
        const randomnessSlider = document.getElementById('randomnessSlider');
        const randomnessValueDisplay = document.getElementById('randomnessValue');
        const minShapeScaleSlider = document.getElementById('minShapeScaleSlider');
        const minShapeScaleValueDisplay = document.getElementById('minShapeScaleValue');
        const maxShapeScaleSlider = document.getElementById('maxShapeScaleSlider');
        const maxShapeScaleValueDisplay = document.getElementById('maxShapeScaleValue');
        const invertToggle = document.getElementById('invertToggle');
        
        const analysisModeSelect = document.getElementById('analysisModeSelect');
        const luminanceControl = document.getElementById('luminanceControl');
        const brightnessThresholdSlider = document.getElementById('brightnessThresholdSlider');
        const brightnessThresholdValueDisplay = document.getElementById('brightnessThresholdValue');
        
        const hslContrastControl = document.getElementById('hslContrastControl');
        const hslContrastSlider = document.getElementById('hslContrastSlider');
        const hslContrastValue = document.getElementById('hslContrastValue');

        const colorMatchControl = document.getElementById('colorMatchControl');
        const colorMatchThresholdSlider = document.getElementById('colorMatchThresholdSlider');
        const colorMatchThresholdValue = document.getElementById('colorMatchThresholdValue');
        const colorMatchColorPicker = document.getElementById('colorMatchColorPicker');

        const bgColorPickerContainer = document.getElementById('bgColorPickerContainer');
        const shapeColorPickerContainer = document.getElementById('shapeColorPickerContainer');
        const downloadResolutionPickerContainer = document.getElementById('downloadResolutionPickerContainer');
        
        const imageUploadInput = document.getElementById('imageUploadInput');
        const uploadTriggerButton = document.getElementById('uploadTriggerButton');
        const dropZone = document.getElementById('dropZone');
        const dropZoneContent = document.getElementById('dropZoneContent');
        const imagePreview = document.getElementById('imagePreview');
        const patternPreviewCanvas = document.getElementById('patternPreviewCanvas');
        const patternPreviewCtx = patternPreviewCanvas.getContext('2d');
        const generateButton = document.getElementById('generateButton');
        
        let originalImage = null;
        let imageAspectRatio = 1;
        // Canvas for grayscale/equalized image processing
        let offscreenImageCanvas = document.createElement('canvas');
        let offscreenImageCtx = offscreenImageCanvas.getContext('2d', { willReadFrequently: true });
        offscreenImageCtx.imageSmoothingEnabled = false;

        // --- Initialization ---
        function initialize() {
            populateColorPickers();
            populateResolutionPicker();
            addEventListeners();
            updateSliderValueDisplays();
            updatePreviewPanes();
        }

        function addEventListeners() {
            const sliders = [patternDensitySlider, randomnessSlider, brightnessThresholdSlider, hslContrastSlider, minShapeScaleSlider, maxShapeScaleSlider, colorMatchThresholdSlider];
            sliders.forEach(slider => {
                slider.addEventListener('input', () => {
                    updateSliderValueDisplays();
                    if (slider === minShapeScaleSlider || slider === maxShapeScaleSlider) {
                         enforceMinMaxScaleLogic.call(slider);
                    }
                    generatePatternForDisplay();
                });
            });

            invertToggle.addEventListener('change', generatePatternForDisplay);
            analysisModeSelect.addEventListener('change', handleAnalysisModeChange);
            colorMatchColorPicker.addEventListener('input', generatePatternForDisplay);

            uploadTriggerButton.addEventListener('click', () => imageUploadInput.click());
            dropZone.addEventListener('click', () => imageUploadInput.click());
            imageUploadInput.addEventListener('change', handleImageUpload);
            
            dropZone.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); dropZone.style.borderColor = '#3b82f6'; });
            dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); dropZone.style.borderColor = '#e5e7eb'; });
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault(); e.stopPropagation();
                dropZone.style.borderColor = '#e5e7eb';
                if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                    loadImageFromFile(e.dataTransfer.files[0]);
                }
            });

            generateButton.addEventListener('click', handleDownload);
        }

        // --- UI Population ---
        function populateColorPickers() {
            const allColors = [...GRAYSCALE_COLORS_CONFIG, ...BRAND_COLORS_CONFIG];
            allColors.forEach(color => {
                createRadioOption(shapeColorPickerContainer, 'shapeColor', color, color.hex === '#0F0F0F', 'visualSwatch');
                createRadioOption(bgColorPickerContainer, 'backgroundColor', color, color.hex === '#FFFFFF', 'visualSwatch');
            });
        }
        
        function populateResolutionPicker() {
            DOWNLOAD_RESOLUTIONS_CONFIG.forEach((res, index) => {
                createRadioOption(downloadResolutionPickerContainer, 'downloadResolution', res, index === 2, 'textButton'); // Default 4K
            });
        }

        function createRadioOption(container, name, optionData, isChecked, type) {
            const radioId = `${name}_${optionData.hex || optionData.value}`;
            const radioInput = document.createElement('input');
            radioInput.type = 'radio';
            radioInput.id = radioId;
            radioInput.name = name;
            radioInput.value = optionData.hex || optionData.value;
            radioInput.className = 'radio-input';
            if (isChecked) radioInput.checked = true;

            const radioLabel = document.createElement('label');
            radioLabel.htmlFor = radioId;

            if (type === 'visualSwatch') {
                radioLabel.className = 'radio-label color-radio';
                radioLabel.innerHTML = `<span class="color-swatch" style="background-color:${optionData.hex};" title="${optionData.name}"></span>`;
                radioInput.addEventListener('change', generatePatternForDisplay);
            } else if (type === 'textButton') {
                radioLabel.className = 'radio-label text-button-label';
                radioLabel.textContent = optionData.name;
            }
            container.appendChild(radioInput);
            container.appendChild(radioLabel);
        }
        
        // --- Event Handlers ---
        function handleImageUpload(event) {
            if (event.target.files && event.target.files[0]) {
                loadImageFromFile(event.target.files[0]);
            }
        }

        function loadImageFromFile(file) {
            const reader = new FileReader();
            reader.onload = e => {
                originalImage = new Image();
                originalImage.onload = () => {
                    imageAspectRatio = originalImage.width / originalImage.height;
                    offscreenImageCanvas.width = originalImage.width;
                    offscreenImageCanvas.height = originalImage.height;
                    
                    // Apply histogram equalization for luminance mode
                    equalizeHistogram();

                    updatePreviewPanes(e.target.result);
                    generatePatternForDisplay();
                };
                originalImage.onerror = () => alert("Error: Could not process the image file.");
                originalImage.src = e.target.result;
            };
            reader.onerror = () => alert("Error: Could not read the file.");
            reader.readAsDataURL(file);
        }
        
        function handleAnalysisModeChange() {
            const mode = analysisModeSelect.value;
            const lumaLabel = luminanceControl.querySelector('label');
            
            // Hide all special controls first
            luminanceControl.classList.add('hidden');
            colorMatchControl.classList.add('hidden');
            hslContrastControl.classList.add('hidden');
            
            // Default to showing the main sensitivity slider
            luminanceControl.classList.remove('hidden');

            switch(mode) {
                case 'luminance':
                    lumaLabel.firstChild.textContent = 'RELATIVE SENSITIVITY';
                    brightnessThresholdSlider.min = -100;
                    brightnessThresholdSlider.max = 200;
                    brightnessThresholdSlider.step = 1;
                    brightnessThresholdSlider.value = 80;
                    break;
                case 'hslAnalysis':
                    lumaLabel.firstChild.textContent = 'INTENSITY';
                    brightnessThresholdSlider.min = 0.1;
                    brightnessThresholdSlider.max = 4.0;
                    brightnessThresholdSlider.step = 0.05;
                    brightnessThresholdSlider.value = 1.5; // Good starting point
                    hslContrastControl.classList.remove('hidden'); // Show contrast slider
                    break;
                case 'colorDissimilarity':
                    lumaLabel.firstChild.textContent = 'TEXTURE SENSITIVITY';
                    brightnessThresholdSlider.min = 0.1;
                    brightnessThresholdSlider.max = 20;
                    brightnessThresholdSlider.step = 0.1;
                    brightnessThresholdSlider.value = 1;
                    break;
                case 'edgeDetection':
                    lumaLabel.firstChild.textContent = 'EDGE SENSITIVITY';
                    brightnessThresholdSlider.min = 0;
                    brightnessThresholdSlider.max = 255;
                    brightnessThresholdSlider.step = 1;
                    brightnessThresholdSlider.value = 128;
                    break;
                case 'colorMatch':
                    luminanceControl.classList.add('hidden');
                    colorMatchControl.classList.remove('hidden');
                    break;
                default:
                     luminanceControl.classList.add('hidden');
                     break;
            }

            updateSliderValueDisplays();
            generatePatternForDisplay();
        }

        function handleDownload() {
            if (!originalImage) {
                alert("Please upload an image first.");
                return;
            }
            
            const selectedResolution = parseInt(getSelectedRadioValue('downloadResolution'));
            const downloadCanvas = document.createElement('canvas');
            const downloadCtx = downloadCanvas.getContext('2d');
            
            generatePatternOnCanvas(downloadCanvas, downloadCtx, true, selectedResolution);
            
            const dataURL = downloadCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `pattern-export-${downloadCanvas.width}x${downloadCanvas.height}.png`;
            link.href = dataURL;
            link.click();
        }

        // --- UI Updates & Logic ---
        function updateSliderValueDisplays() {
            patternDensityValueDisplay.textContent = `(${patternDensitySlider.value})`;
            randomnessValueDisplay.textContent = `(${parseFloat(randomnessSlider.value).toFixed(2)})`;
            
            const mode = analysisModeSelect.value;
            const sensitivityValue = parseFloat(brightnessThresholdSlider.value);
            const contrastValue = parseFloat(hslContrastSlider.value);

            switch(mode) {
                case 'luminance':
                    brightnessThresholdValueDisplay.textContent = `(${sensitivityValue > 0 ? '+' : ''}${sensitivityValue}%)`;
                    break;
                case 'hslAnalysis':
                     brightnessThresholdValueDisplay.textContent = `(x${sensitivityValue.toFixed(1)})`;
                     hslContrastValue.textContent = `(x${contrastValue.toFixed(1)})`;
                     break;
                case 'colorDissimilarity':
                     brightnessThresholdValueDisplay.textContent = `(x${sensitivityValue.toFixed(1)})`;
                     break;
                case 'edgeDetection':
                     brightnessThresholdValueDisplay.textContent = `(${Math.round(sensitivityValue)})`;
                     break;
            }
            
            minShapeScaleValueDisplay.textContent = `(${parseFloat(minShapeScaleSlider.value).toFixed(2)})`;
            maxShapeScaleValueDisplay.textContent = `(${parseFloat(maxShapeScaleSlider.value).toFixed(2)})`;
            colorMatchThresholdValue.textContent = `(${colorMatchThresholdSlider.value})`;
        }
        
        function enforceMinMaxScaleLogic() {
            let minVal = parseFloat(minShapeScaleSlider.value);
            let maxVal = parseFloat(maxShapeScaleSlider.value);
            if (minVal > maxVal) {
                if (this === minShapeScaleSlider) maxShapeScaleSlider.value = minVal;
                else minShapeScaleSlider.value = minVal;
            }
        }

        function updatePreviewPanes(imageSrc = null) {
            const aspectRatioCSS = `${imageAspectRatio}`;
            dropZone.style.setProperty('--image-aspect-ratio', aspectRatioCSS);
            document.getElementById('patternPreviewContainer').style.setProperty('--image-aspect-ratio', aspectRatioCSS);
            
            if (imageSrc) {
                imagePreview.src = imageSrc;
                imagePreview.classList.remove('hidden');
                dropZoneContent.classList.add('hidden');
            } else {
                 imagePreview.classList.add('hidden');
                 dropZoneContent.classList.remove('hidden');
                 generatePatternForDisplay();
            }
        }
        
        function getSelectedRadioValue(name) {
            const selected = document.querySelector(`input[name="${name}"]:checked`);
            return selected ? selected.value : null;
        }

        // --- HELPER FUNCTIONS ---

        // For HSL Analysis Mode
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h, s, l };
        }

        // For Color Dissimilarity (Texture) Mode
        function calculateColorDistance(r1, g1, b1, r2, g2, b2) {
            return Math.sqrt(Math.pow(r1 - r2, 2) + Math.pow(g1 - g2, 2) + Math.pow(b1 - b2, 2));
        }

        function createDissimilarityMap(imageData) {
            const { data, width, height } = imageData;
            const dissimilarityData = new Uint8ClampedArray(data.length);
            let maxDistance = 0;
            const distances = new Float32Array(data.length / 4);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const centerIndex = (y * width + x) * 4;
                    let avgR = 0, avgG = 0, avgB = 0;
                    for (let j = -1; j <= 1; j++) {
                        for (let i = -1; i <= 1; i++) {
                            if (i === 0 && j === 0) continue;
                            const neighborIndex = ((y + j) * width + (x + i)) * 4;
                            avgR += data[neighborIndex];
                            avgG += data[neighborIndex + 1];
                            avgB += data[neighborIndex + 2];
                        }
                    }
                    avgR /= 8; avgG /= 8; avgB /= 8;
                    const distance = calculateColorDistance(
                        data[centerIndex], data[centerIndex+1], data[centerIndex+2],
                        avgR, avgG, avgB
                    );
                    const flatIndex = y * width + x;
                    distances[flatIndex] = distance;
                    if (distance > maxDistance) maxDistance = distance;
                }
            }
            
            if (maxDistance === 0) maxDistance = 1; // Avoid division by zero for solid color images
            for (let i = 0; i < distances.length; i++) {
                const normalizedValue = (distances[i] / maxDistance) * 255;
                const outputIndex = i * 4;
                dissimilarityData[outputIndex] = normalizedValue;
                dissimilarityData[outputIndex+1] = normalizedValue;
                dissimilarityData[outputIndex+2] = normalizedValue;
                dissimilarityData[outputIndex+3] = 255;
            }
            return new ImageData(dissimilarityData, width, height);
        }
        
        // --- Core Drawing Logic ---
        function equalizeHistogram() {
            const srcCtx = document.createElement('canvas').getContext('2d');
            srcCtx.canvas.width = originalImage.width;
            srcCtx.canvas.height = originalImage.height;
            srcCtx.drawImage(originalImage, 0, 0);
            const imageData = srcCtx.getImageData(0, 0, srcCtx.canvas.width, srcCtx.canvas.height);
            const data = imageData.data;
            const hist = new Array(256).fill(0);

            // Calculate histogram
            for (let i = 0; i < data.length; i += 4) {
                const luma = Math.round(0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2]);
                hist[luma]++;
            }

            // Calculate cumulative distribution function (CDF)
            const cdf = new Array(256).fill(0);
            cdf[0] = hist[0];
            for (let i = 1; i < 256; i++) {
                cdf[i] = cdf[i-1] + hist[i];
            }

            // Find min CDF value
            let cdfMin = 0;
            for(let i = 0; i < 256; i++) {
                if (cdf[i] > 0) {
                    cdfMin = cdf[i];
                    break;
                }
            }

            // Create lookup table (LUT)
            const lut = new Array(256);
            const numPixels = data.length / 4;
            for (let i = 0; i < 256; i++) {
                lut[i] = Math.round(255 * (cdf[i] - cdfMin) / (numPixels - cdfMin));
            }
            
            // Apply LUT to image data
            for (let i = 0; i < data.length; i += 4) {
                const luma = Math.round(0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2]);
                const newLuma = lut[luma];
                data[i] = newLuma;
                data[i+1] = newLuma;
                data[i+2] = newLuma;
            }

            // Put the equalized data onto the offscreen canvas for processing
            offscreenImageCtx.putImageData(imageData, 0, 0);
        }

        function generatePatternForDisplay() {
            generatePatternOnCanvas(patternPreviewCanvas, patternPreviewCtx, false);
        }

        function generatePatternOnCanvas(canvas, ctx, isForDownload = false, downloadMaxDim = 0) {
            let canvasWidth, canvasHeight;
            let currentAspectRatio = originalImage ? imageAspectRatio : 1;

            if (isForDownload) {
                if (currentAspectRatio >= 1) { canvasWidth = downloadMaxDim; canvasHeight = downloadMaxDim / currentAspectRatio; } 
                else { canvasHeight = downloadMaxDim; canvasWidth = downloadMaxDim * currentAspectRatio; }
            } else {
                const containerRect = canvas.parentElement.getBoundingClientRect();
                 if (containerRect.width / containerRect.height > currentAspectRatio) {
                    canvasHeight = containerRect.height;
                    canvasWidth = canvasHeight * currentAspectRatio;
                } else {
                    canvasWidth = containerRect.width;
                    canvasHeight = canvasWidth / currentAspectRatio;
                }
            }
            canvas.width = Math.round(canvasWidth);
            canvas.height = Math.round(canvasHeight);

            const bgColor = getSelectedRadioValue('backgroundColor');
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!originalImage) {
                ctx.fillStyle = "#9ca3af";
                ctx.font = "14px 'Roboto Mono'";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("Pattern Preview", canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const density = parseInt(patternDensitySlider.value);
            const randomness = parseFloat(randomnessSlider.value);
            const minScale = parseFloat(minShapeScaleSlider.value);
            const maxScale = parseFloat(maxShapeScaleSlider.value);
            const invert = invertToggle.checked;
            const analysisMode = analysisModeSelect.value;
            const sensitivity = parseFloat(brightnessThresholdSlider.value);
            const contrast = parseFloat(hslContrastSlider.value);
            const targetColor = analysisMode === 'colorMatch' ? hexToRgb(colorMatchColorPicker.value) : null;
            const shapeColor = getSelectedRadioValue('shapeColor');
            ctx.fillStyle = shapeColor;
            
            // --- DATA HANDLING ---
            const colorCanvas = document.createElement('canvas');
            colorCanvas.width = originalImage.width;
            colorCanvas.height = originalImage.height;
            const colorCtx = colorCanvas.getContext('2d', { willReadFrequently: true });
            colorCtx.drawImage(originalImage, 0, 0);
            const originalColorImageData = colorCtx.getImageData(0, 0, originalImage.width, originalImage.height);
            
            let processedImageData;
            if (analysisMode === 'colorDissimilarity') {
                processedImageData = createDissimilarityMap(originalColorImageData);
            } else {
                processedImageData = offscreenImageCtx.getImageData(0, 0, offscreenImageCanvas.width, offscreenImageCanvas.height);
            }
            
            const data = processedImageData.data;
            const colorData = originalColorImageData.data;
            
            const gridCols = density;
            const gridRows = Math.round(density / currentAspectRatio);
            const cellWidth = canvas.width / gridCols;
            const cellHeight = canvas.height / gridRows;

            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    const sampleX = Math.floor((col + 0.5) / gridCols * offscreenImageCanvas.width);
                    const sampleY = Math.floor((row + 0.5) / gridRows * offscreenImageCanvas.height);
                    const pixelIndex = (sampleY * offscreenImageCanvas.width + sampleX) * 4;
                    
                    let strengthFactor = 0;
                    let conditionMet = false;

                    switch (analysisMode) {
                        case 'luminance': {
                            const brightness = data[pixelIndex];
                            const sensitivityMultiplier = 1.0 + (sensitivity / 100.0);
                            const baseStrength = invert ? (brightness / 255.0) : ((255.0 - brightness) / 255.0);
                            
                            if (baseStrength > 0.01) {
                                strengthFactor = baseStrength * sensitivityMultiplier;
                                conditionMet = true;
                            }
                            break;
                        }
                        case 'hslAnalysis': {
                            const r = colorData[pixelIndex];
                            const g = colorData[pixelIndex + 1];
                            const b = colorData[pixelIndex + 2];
                            const { l } = rgbToHsl(r, g, b);

                            let baseStrength = (1.0 - l);
                            
                            // Apply Intensity
                            baseStrength = Math.pow(baseStrength, sensitivity);
                            
                            // Apply Contrast
                            const contrastFactor = contrast;
                            baseStrength = 0.5 + contrastFactor * (baseStrength - 0.5);

                            strengthFactor = baseStrength;
                            if (invert) strengthFactor = 1.0 - strengthFactor;
                            conditionMet = true;
                            break;
                        }
                        case 'colorDissimilarity': {
                            const textureStrength = data[pixelIndex] / 255.0;
                            strengthFactor = textureStrength * sensitivity; // Use slider as multiplier
                            if (invert) strengthFactor = (1.0 - (data[pixelIndex] / 255.0)) * sensitivity;
                            conditionMet = true;
                            break;
                        }
                        case 'colorMatch': {
                             const r = colorData[pixelIndex];
                             const g = colorData[pixelIndex + 1];
                             const b = colorData[pixelIndex + 2];
                             const distance = calculateColorDistance(r, g, b, targetColor.r, targetColor.g, targetColor.b);
                             const threshold = parseInt(colorMatchThresholdSlider.value);

                             if ((invert && distance > threshold) || (!invert && distance <= threshold)) {
                                 strengthFactor = 1.0;
                                 conditionMet = true;
                             }
                             break;
                        }
                    }

                    if (conditionMet && strengthFactor > 0) {
                        strengthFactor = Math.max(0, Math.min(1, strengthFactor));
                        const scale = minScale + strengthFactor * (maxScale - minScale);
                        const shapeSize = Math.min(cellWidth, cellHeight) * scale;
                        const centerX = (col + 0.5) * cellWidth;
                        const centerY = (row + 0.5) * cellHeight;
                        const isCircle = Math.random() < randomness;
                        drawShape(ctx, centerX, centerY, shapeSize, isCircle);
                    }
                }
            }
        }
        
        function drawShape(ctx, x, y, size, isCircle) {
            ctx.beginPath();
            if (isCircle) {
                ctx.arc(x, y, size / 2, 0, Math.PI * 2);
            } else {
                const side = size * 0.75;
                ctx.rect(x - side / 2, y - side / 2, side, side);
            }
            ctx.fill();
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
        }

        document.addEventListener('DOMContentLoaded', () => {
            initialize();
            // Set initial state correctly
            handleAnalysisModeChange();
        });
    </script>
</body>
</html>
